{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE DataKinds #-}

module DiscreteLogarithm.Logarithm where

import Prelude hiding (quot)
import Algebra.AlgebraicHierarchy
import Mod.Integer
import Mod.PrimeField
import Data.List
import Data.Map (Map)
import qualified Data.Map as Map

-- Look for a n such that x^n = y (i.e. log_x y = n)
bruteForce :: forall a. (Eq a, FiniteField a) => a -> a -> Maybe Integer
bruteForce x y
  | y == one = Just 0
  | otherwise = aux x 1
  where
    aux :: a -> Integer -> Maybe Integer
    aux beta i
      | beta == one = Nothing
      | beta /= y = aux (beta <.> x) (i + 1)
      | beta == y = Just i
      

-- We assume that x is of order q and that y does in fact belong to the cyclic
-- group generated by x
babyStepGiantStep :: forall a. (Ord a, FiniteField a) => a -> Integer -> a -> Integer
babyStepGiantStep x q y = fst giantStep * m + snd giantStep
  where
    m = floor $ sqrt $ fromIntegral q :: Integer
    m' = q `quot` m

    babyStep :: Map a Integer
    babyStep = Map.fromList $ genericTake m xs
      where
        xs :: [(a,Integer)]
        xs = (one,0) : [(beta <.> x,i+1) | (beta,i) <- xs]

    giantStep :: (Integer, Integer)
    giantStep = loop y 0 (Map.lookup y babyStep)
      where
        x' = x <^> (-m)

        loop :: a -> Integer -> Maybe Integer -> (Integer,Integer)
        loop beta j i = case i of
          Nothing   -> let newbeta = beta <.> x' in loop newbeta (j + 1) (Map.lookup newbeta babyStep)
          Just ival -> (j,ival)
-- We only need an aproximation of q, if we want the exact value we can use
-- mulOrd, but in that case we could alse have constructed a table with all the values

-- Pruebas
gen = 11 :: IntegerMod 100129 -- A generator of the multiplicative group
discLog = bruteForce 11 (11 <^^> 100127 :: IntegerMod 100129)

discLog' = babyStepGiantStep 11 100128 (11 <^^> 100127 :: IntegerMod 100129)
